use nfa::Nfa;
use std::{io::Write, str::FromStr};
use utils::{minimize, save_as};

use crate::{algorithms::{calc_right_language, initialize_rel_table}, utils::{print_language, print_equivalence_classes}};

#[allow(dead_code)]
mod algorithms;
mod nfa;
#[allow(dead_code)]
mod utils;

fn main() {
    let source_file = "mini_tests/nfa.gv";
    //let source_file = "tests/small-11.gv";
    let source = std::fs::read_to_string(source_file).unwrap();
    let nfa = Nfa::from_str(&source).unwrap();

    let rev_nfa = nfa.reverse();
    save_as(&rev_nfa, "rev_nfa");

    let right_language = calc_right_language(&rev_nfa);
    let left_language = calc_right_language(&nfa);

    println!("Right Language");
    print_language(&right_language);
    println!("Left Language");
    print_language(&left_language);

    let right = algorithms::calc_relation(&nfa, &right_language);
    let left = algorithms::calc_relation(&rev_nfa, &left_language);

    let table = initialize_rel_table(&nfa, &right, &left);
    println!("\n(p, q)  \t| Right\t| Left\t| Loop(p)");
    println!("-----------------------------------------");
    for (p, q) in table.keys() {
        let value = table.get(&(p.to_owned(), q.to_owned())).unwrap();
        println!(
            "({}, {})  \t| {}\t| {}\t| {}",
            p, q, value.0, value.1, value.2
        );
    }

    let res =
        algorithms::minimization::preorders_with_priority(nfa.states(), &table, &right, &left);
    let min_pre1 = algorithms::build_minimized(&nfa, &res);
    save_as(&min_pre1, "minimized/pre_priority");
    print_equivalence_classes("Preorder1 Equivalence classes", &res);
}
